---
title: 'Custom tools'
description: 'Extend Smooth with custom Python functions that run in your environment'
---

## Overview

Custom tools allow you to give Smooth any arbitrary function as a tool. This is similar to MCP (Model Context Protocol) but without having to deal with servers or additional infrastructure.

Custom tools can be used for virtually anything, including:

- **Browser interaction** - Execute JavaScript to manipulate the DOM or extract data
- **Human-in-the-loop** - Ask questions and get input from a human operator
- **Handling OTP scenarios** - Retrieve one-time passwords from your email or SMS service
- **Database operations** - Add, update, or query data in your local or remote databases
- **API integrations** - Call external APIs that require credentials or complex logic
- **File system operations** - Read configuration files, process local data, etc.
- **Custom validation** - Implement business-specific validation logic

## Basic Usage

Use the `@client.tool()` decorator to register a Python function as a custom tool. You can then pass this tool to `client.run()` or `session.run_task()`.

### Synchronous Client

<CodeGroup>

```python Python
from smooth import SmoothClient

client = SmoothClient(api_key="cmzr-YOUR_API_KEY")

@client.tool(
    name="get_weather",
    description="Retrieves the current weather for a given city.",
    inputs={
        "city": {
            "type": "string",
            "description": "The city to get the weather for",
        }
    },
    output="string"
)
def get_weather(city: str):
    # You could call an external API here
    return f"The weather in {city} is sunny, 25Â°C"

# Register the tool by passing it to the custom_tools list
with client.session() as session:
    session.run_task(
        "Find the capital of France and then tell me the weather there",
        custom_tools=[get_weather]
    )
```

</CodeGroup>

### Asynchronous Client (Recommended)

When using `SmoothAsyncClient`, your custom tools must be `async`.

<CodeGroup>

```python Python
from smooth import SmoothAsyncClient

client = SmoothAsyncClient(api_key="cmzr-YOUR_API_KEY")

@client.tool(
    name="get_data",
    description="Fetches data from an internal API",
    inputs={},
    output="string"
)
async def get_data():
    # async logic here
    return "Some data"

async def main():
    async with await client.session() as session:
        await session.run_task("Analyze the dashboard", custom_tools=[get_data])
```

</CodeGroup>

## Browser JavaScript Execution

Within custom tools, you can execute JavaScript directly in the browser context. Your JavaScript code has full access to the DOM, browser APIs, and page state.

To use this feature, add a `task: smooth.TaskHandle` parameter to your tool function. This handle allows you to call methods like `evaluate_js()`, `goto()`, and `extract()` directly from within your tool.

<CodeGroup>

```python Python
import smooth
import time

client = smooth.SmoothClient(api_key="cmzr-YOUR_API_KEY")

@client.tool(
    name="highlight_and_click",
    description="Highlights an element using a CSS selector and then clicks it.",
    inputs={
        "selector": {
            "type": "string",
            "description": "The CSS selector of the element to highlight and click",
        }
    },
    output="string"
)
def highlight_and_click(task: smooth.TaskHandle, selector: str):
    # 1. Use evaluate_js to manipulate the page
    success = task.evaluate_js(f"""
        (selector) => {{
            const el = document.querySelector(selector);
            if (el) {{
                el.style.border = '5px solid red';
                el.scrollIntoView();
                return true;
            }}
            return false;
        }}
    """, selector)

    if not success:
        return f"Element with selector {selector} not found"

    # 2. Wait a bit so the highlight is visible in the recording
    time.sleep(1)

    # 3. Use another browser action
    task.evaluate_js(f"() => document.querySelector('{selector}').click()")

    return f"Successfully highlighted and clicked {selector}"
```

</CodeGroup>

<Note>
  When using the **Async Client**, your tool functions **must** be `async def` and you should `await` all task methods.
</Note>

<Tip>
Use JavaScript for browser-level automation and data extraction, and Python for backend processing and integrations. Combine both for powerful workflows.
</Tip>

## Tool Decorator Parameters

The `@client.tool()` decorator accepts the following parameters:

<ParamField path="name" type="string" required>
  The name of the tool that the agent will see and use to call it. Use descriptive, clear names.
</ParamField>

<ParamField path="description" type="string" required>
  A clear description of what the tool does and when to use it. The agent uses this to decide when to call your tool.
</ParamField>

<ParamField path="inputs" type="dict" required>
  A dictionary describing the input parameters for the tool. Each key is a parameter name, and the value is an object with:
  - `type` (string): The data type (e.g., "string", "number", "boolean", "object", "array")
  - `description` (string): A clear description of what this parameter is for
</ParamField>

<ParamField path="output" type="string" required>
  The return type of the tool (e.g., "string", "number", "boolean", "object", "array")
</ParamField>

## Error Handling

Custom tools support two types of error handling:

### ToolCallError (Non-Fatal)

Use `ToolCallError` for expected errors that the agent should handle gracefully. The error message will be sent to the agent, allowing it to retry or adjust its approach.

```python
from smooth import ToolCallError

@client.tool(
    name="validate_code",
    description="Validates a verification code",
    inputs={"code": {"type": "string", "description": "The code to validate"}},
    output="boolean"
)
def validate_code(code: str):
    if not code.isdigit():
        raise ToolCallError("Code must contain only digits")
    if len(code) != 6:
        raise ToolCallError("Code must be exactly 6 digits")
    return True
```

### Fatal Exceptions

Any other exception raised by your code is considered fatal and will immediately interrupt the task execution.

```python
@client.tool(
    name="query_database",
    description="Queries the user database",
    inputs={"user_id": {"type": "string", "description": "User ID to query"}},
    output="object"
)
def query_database(user_id: str):
    try:
        # Database query logic
        result = db.query(user_id)
        return result
    except ConnectionError:
        # This will stop the task immediately
        raise Exception("Database connection failed - critical error")
```

<Tip>
**Tool Descriptions**: Write clear, specific descriptions for your tools and inputs. The agent relies on these descriptions to decide when and how to use your tools effectively.
</Tip>

## Best Practices

1. **Keep tools simple to use** - Each tool should do one thing well
2. **Use descriptive names** - Name tools clearly so the agent knows when to use them
3. **Handle errors gracefully** - Use `ToolCallError` for recoverable errors
4. **Validate inputs** - Check that inputs are in the expected format before processing
5. **Return meaningful values** - Provide clear, actionable responses that help the agent continue
6. **Test independently** - Test your tool functions separately before using them in tasks
